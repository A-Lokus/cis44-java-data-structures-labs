I am choosing option B, the Smart Scheduler, with the presented issue and goal of managing an incoming stream of requests where certain tasks are more urgent than others regardless of when they were inputted. To remedy this situation, I will choose to implement a Min-Heap Priority Queue data structure where the incoming requests are inserted as entries with key values, most likely integers, identifying their priority with the value of each entry being the task requested. The lower the value of the key, the higher priority (e.g. 0 is the highest priority, 1 is second most important, etc.). Each insertion of a new request entry into the heap will check to see if an upheap is required to make sure the minimum key, or the highest priority task, is at the top of the heap. After or when executing the highest priority task, I will remove the task from the heap of pending tasks and then follow the downheap procedure to ensure the heap maintains the properties of a Min-Heap. Although it would be possible to implement a Max-Heap for the same situation, I will be choosing to utilize a Min-Heap based on my familiarity with the implementation as well as the hierarchical nature of a Min-Heap where high-priority inserted tasks would be assigned lesser numbers signifying their urgency. Furthermore, this implementation of a Heap is imperative to ensure that higher priority tasks are handled before lower priority tasks inserted earlier, as each time a new task is inserted, the highest priority task is placed first, regardless of whether or not there were lower-order tasks inserted prior.

Given that I am using a Min-Heap Priority Queue as my design structure, I expect to have Big-O complexities of O(log n) for insertion of new task requests and removal of a task from the heap once executed, and if need be, O(n log n) time complexity for a heap sort in the event of a filled set of data aimed to be reordered in terms of priority, however the main implementation will focus on O(log n) complexity for insertion and removal. This efficiency is due to the Heap Priority Queue data structure involving O(log n) time complexity for insertion and deletion given that the top entry will always be the minimum, and each insertion and removal will use O(log n) time due to the height of the heap and the required swaps to carry out upheap and downheap methods following insertion and removal respectively. Therefore, I expect Big-O time complexities of O(log n) for both insertion and removal of task requests due to the nature of the Heap Priority Queue data structure implenentation I intend to use for the problem presented in option B.
